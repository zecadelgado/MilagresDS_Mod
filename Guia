
# Guia Definitivo de Java com Minecraft: Criando o Mod Milagres DS

**Versão 2.0 - Integrada**

**Autor:** Rafael (com assistência de Manus AI)

---

## Bem-vindo, Aprendiz de Mago!

Este não é um guia comum de programação. É uma jornada épica onde você aprenderá os segredos da linguagem **Java** não através de exemplos abstratos, mas forjando seu próprio mod de magias para o **Minecraft 1.20.1**. Ao final desta aventura, você não apenas terá um mod funcional, mas também um profundo entendimento de conceitos essenciais de desenvolvimento de software.

O objetivo é claro: criar o **Milagres DS**, um mod que adiciona um sistema completo de magias, com menu de seleção, teclas de atalho, sistema de mana e multiplayer funcional.

---

## PARTE I: FUNDAMENTOS

### Capítulo 1: Visão Geral e Objetivos

Nesta seção, preparamos o terreno para nossa jornada, entendendo o que vamos construir e como cada feature do mod se traduz em um poderoso conceito de Java.

#### O que vamos construir?

- **Sistema de Magias Flexível:** Uma base de código que permite adicionar novas magias facilmente.
- **Menu de Seleção:** Uma interface gráfica para o jogador escolher qual magia equipar.
- **Teclas de Atalho:** Controles customizáveis para lançar magias e abrir o menu.
- **Sistema de Mana:** Um recurso que é consumido ao usar magias, com regeneração e HUD visual.
- **Networking:** Garantir que tudo funcione perfeitamente em um servidor multiplayer.

| Recurso do Mod | Conceito Java Aplicado |
|---|---|
| **Classe Base `Spell`** | `abstract class`, Herança, Polimorfismo |
| **Registro de Magias** | `static`, `final`, Padrão Registry, Generics (`<Spell>`) |
| **Sistema de Mana** | Interfaces, `Capability` (Forge), `Optional` |
| **Menu de Seleção (GUI)** | Herança de classes da UI, Event Handling, Streams (`forEach`) |
| **Teclas de Atalho** | `static final`, Event Handling |
| **Networking** | Serialização, `Supplier<T>`, Lambdas (`->`) |

---

### Capítulo 2: Configuração do Ambiente

Todo mago precisa de seu laboratório. Aqui, configuramos nosso ambiente de desenvolvimento.

**Pré-requisitos:**
- **JDK 17:** A versão correta do Java. Verifique com `java -version`.
- **IntelliJ IDEA:** Nosso editor de código.
- **Forge MDK 1.20.1:** O kit de desenvolvimento do Forge.

**Passos:**
1.  Extraia o Forge MDK em uma pasta chamada `MilagresDS_Mod`.
2.  Abra a pasta no IntelliJ IDEA.
3.  Aguarde o Gradle sincronizar. Isso pode levar alguns minutos.
4.  Execute a tarefa `runClient` do Gradle para testar. O Minecraft deve abrir.

#### Exercício Prático 2.1: Personalize seu Projeto

Abra o arquivo `mods.toml` em `src/main/resources/META-INF/` e altere os campos `displayName`, `authors` e `description` com suas informações. Execute o jogo e veja suas alterações no menu de mods!

---

### Capítulo 3: Estrutura do Projeto

Organização é a chave para um código limpo e escalável.

```
src/main/java/com/rafael/milagresds/
├── MilagresDSMod.java          # Classe principal
├── magic/                     # Sistema de magias
│   ├── Spell.java               # Classe abstrata base
│   └── spells/                  # Implementações de magias
├── registry/                    # Registros (magias, itens, etc.)
├── client/                      # Código do lado do cliente
│   ├── gui/                     # Interfaces gráficas
│   └── keybindings/             # Teclas de atalho
├── capability/                  # Dados customizados do jogador (mana)
└── network/                     # Pacotes de rede cliente-servidor
```

---

## PARTE II: DESENVOLVENDO O MOD DE MAGIAS

Agora começa a verdadeira magia! Vamos codificar cada parte do nosso sistema.

### Capítulo 4: A Base da Magia - Classes Abstratas e Herança

Para criar um sistema flexível, não definimos o que é uma "bola de fogo", mas sim o que é uma "magia" em geral. Isso é **abstração**.

**Arquivo:** `com/rafael/milagresds/magic/Spell.java`
```java
public abstract class Spell {
    private final String name;
    private final int manaCost;
    // ... outras propriedades ...

    public Spell(String name, int manaCost, ...) {
        this.name = name;
        this.manaCost = manaCost;
    }

    // Cada magia DEVE implementar este método
    public abstract void cast(Player player, Level level);

    // Getters
    public String getName() { return this.name; }
    public int getManaCost() { return this.manaCost; }
}
```
**Conceito Java:** Uma **classe abstrata** é um contrato. Ela diz: "Qualquer coisa que queira ser uma `Spell` precisa ter um nome, um custo de mana e, mais importante, precisa saber como ser `cast` (lançada)".

---

### Capítulo 5: A Primeira Magia - Implementação e Polimorfismo

Agora, vamos criar uma magia concreta que segue o contrato da nossa classe `Spell`.

**Arquivo:** `com/rafael/milagresds/magic/spells/FireballSpell.java`
```java
public class FireballSpell extends Spell {
    public FireballSpell() {
        super("Bola de Fogo", 20, ...);
    }

    @Override
    public void cast(Player player, Level level) {
        // Lógica para lançar uma bola de fogo
        if (!level.isClientSide) {
            LargeFireball fireball = new LargeFireball(...);
            level.addFreshEntity(fireball);
        }
    }
}
```
**Conceito Java:** **Herança** (`extends`). `FireballSpell` é uma `Spell`. Ela herda as propriedades e implementa o método abstrato `cast`. Isso é **polimorfismo**: podemos tratar uma `FireballSpell` como se fosse simplesmente uma `Spell`, o que torna nosso código muito mais flexível.

---

### Capítulo 6: O Grimório - Registro de Magias

O Minecraft precisa saber que nossas magias existem. Para isso, as registramos.

**Arquivo:** `com/rafael/milagresds/registry/SpellRegistry.java`
```java
public class SpellRegistry {
    public static final DeferredRegister<Spell> SPELLS =
            DeferredRegister.create(new ResourceLocation(MODID, "spells"), MODID);

    public static final Supplier<IForgeRegistry<Spell>> REGISTRY =
            SPELLS.makeRegistry(RegistryBuilder::new);

    // Registrar magias
    public static final RegistryObject<Spell> FIREBALL = SPELLS.register("fireball", FireballSpell::new);
}
```
**Conceito Java:**
- **`static final`**: Constantes. `FIREBALL` é uma referência única e imutável para nossa magia.
- **Generics**: `DeferredRegister<Spell>` garante que apenas objetos do tipo `Spell` podem ser registrados aqui, evitando erros.
- **Referência de Método**: `FireballSpell::new` é uma forma elegante de dizer "use o construtor de `FireballSpell` para criar o objeto quando for a hora certa".

---

### Capítulo 7: O Poder Interior - Gerenciando Mana com Capabilities

Precisamos armazenar dados customizados no jogador (sua mana). O Forge usa um sistema chamado **Capabilities** para isso.

1.  **Defina a Interface:** Crie uma interface `IPlayerMana` com métodos como `getMana()`, `consumeMana()`, etc.
2.  **Crie a Implementação:** Crie uma classe `PlayerMana` que implementa `IPlayerMana`.
3.  **Crie o Provider:** Crie um `PlayerManaProvider` que anexa a capability ao jogador.
4.  **Registre o Evento:** Use o evento `AttachCapabilitiesEvent<Entity>` para anexar o provider ao jogador.

**Conceito Java:** **Interfaces**. Elas definem um contrato (`o que` um sistema de mana deve fazer) sem se preocupar com a implementação (`como` ele faz). Isso desacopla nosso código.

---

### Capítulo 8: A Interface do Mago - Teclas e GUI

**8.1: Teclas de Atalho:**
- Crie uma classe `ModKeybindings` para definir as teclas (`M` para menu, `R` para lançar).
- Registre-as no evento `RegisterKeyMappingsEvent`.

**8.2: Handler de Input:**
- Crie uma classe `KeyInputHandler` que ouve o evento `InputEvent.Key`.
- Quando a tecla `M` for pressionada, abra a tela de seleção.
- Quando a tecla `R` for pressionada, envie um pacote para o servidor.

**8.3: A Tela de Seleção:**
- Crie uma classe `SpellSelectionScreen` que herda de `net.minecraft.client.gui.screens.Screen`.
- No método `render()`, desenhe o fundo, o título e os ícones de cada magia registrada.
- Use `SpellRegistry.REGISTRY.get().getValues().forEach(...)` para iterar sobre todas as magias.

**Conceito Java:** **Event Handling** e **Streams**. Ouvimos eventos do jogo e reagimos a eles. Usamos Streams para processar a lista de magias de forma funcional e elegante.

---

### Capítulo 9: Magia Multiplayer - Networking

Para que as magias funcionem em um servidor, o cliente precisa **avisar** o servidor de sua intenção.

1.  **Crie um `SimpleChannel`:** O canal de comunicação do seu mod.
2.  **Crie um Pacote:** Crie uma classe `CastSpellPacket`. Ela não precisa de campos, pois o servidor já sabe qual magia o jogador tem equipada.
3.  **Implemente o `handle()`:** No método `handle` do pacote, que é executado no servidor:
    - Obtenha o jogador (`context.getSender()`).
    - Verifique a mana e o cooldown.
    - Se tudo estiver OK, consuma a mana e chame o método `cast()` da magia.
4.  **Envie o Pacote:** No `KeyInputHandler`, quando a tecla `R` for pressionada, envie o pacote: `ModPackets.sendToServer(new CastSpellPacket());`

**Conceito Java:** **Serialização** (embora nosso pacote seja simples) e **Programação Concorrente**. O método `handle` é executado em um thread de rede, e usamos `context.enqueueWork()` para garantir que a lógica da magia seja executada no thread principal do servidor, evitando problemas de concorrência.

---

## PARTE III: PRÁTICA E CONSOLIDAÇÃO

Agora que você viu a teoria, é hora de sujar as mãos!

### Capítulo 10: Exercícios Práticos

#### Exercício 1: Crie uma Magia de Cura

1.  Crie uma classe `HealSpell` que herda de `Spell`.
2.  No construtor, defina o custo de mana e cooldown.
3.  No método `cast()`, use `player.heal(10.0F)` para curar 5 corações.
4.  Registre a nova magia no `SpellRegistry`.
5.  Crie um ícone para ela e teste no jogo!

#### Exercício 2: Custo de Mana Configurável

1.  Usando o sistema de configuração do Forge (`ForgeConfigSpec`), adicione uma configuração para o custo de mana da `FireballSpell`.
2.  Na classe `FireballSpell`, em vez de um número fixo, leia o valor da configuração.

#### Exercício 3: Som e Partículas

1.  No método `cast()` da `FireballSpell`, adicione `level.playSound(...)` para tocar um som de lançamento.
2.  No lado do servidor, use `serverLevel.sendParticles(...)` para criar uma explosão de partículas na localização do jogador quando a magia for lançada.

---

### Capítulo 11: Soluções Comentadas

*(Esta seção conteria o código completo e explicado para os exercícios acima, similar ao documento `SOLUCOES_EXERCICIOS.md` gerado anteriormente)*

---

## PARTE IV: GERENCIAMENTO E RECURSOS

### Capítulo 12: Gerenciando seu Projeto com Kanban

Um projeto de modding pode ficar complexo. Usar um quadro Kanban ajuda a organizar as tarefas. Ele se divide em colunas como "A Fazer", "Em Progresso" e "Concluído".

**Exemplo de Tarefa:**
- **Título:** Implementar Magia de Cura
- **Descrição:** Criar a classe `HealSpell`, registrar e adicionar ícone.
- **Critérios de Aceitação:** Magia cura o jogador e consome mana ao ser lançada.
- **Status:** A Fazer

*(Esta seção incluiria uma versão simplificada do `KANBAN_MILAGRES_DS.md`)*

---

### Capítulo 13: Troubleshooting

- **Item/Magia não aparece:** Verifique se o `DeferredRegister` foi registrado no event bus e se o `modid` está correto.
- **Textura roxa e preta:** O caminho para o arquivo `.png` no seu JSON de modelo está errado.
- **Crash ao iniciar:** Leia o `crash-report`. Geralmente, é um `NullPointerException` por tentar acessar algo cedo demais.
- **Teclas não funcionam:** Verifique se o `KeyInputHandler` está registrado e se não há conflitos de teclas.

---

## Conclusão e Próximos Passos

Parabéns, Mago! Você completou a jornada de criação de um mod de magias, aprendendo conceitos de Java que vão muito além do Minecraft. Você aprendeu sobre abstração, herança, polimorfismo, interfaces, generics, eventos, networking e muito mais.

O que vem agora?
- **Expanda seu grimório:** Crie magias de área (AOE), buffs, debuffs, etc.
- **Crie um sistema de progressão:** Faça o jogador aprender ou encontrar magias.
- **Refatore seu código:** Aplique os padrões que aprendeu para tornar seu código ainda melhor.

A magia da programação está em suas mãos. Continue aprendendo, continue criando!

